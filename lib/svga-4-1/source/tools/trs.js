// Generated by CoffeeScript 2.7.0
(function() {
  // These are Ivan's SVG tools. They're private APIs, part of the implementation of SVGA.
  // They're not to be used by content, since they might endure breaking changes at any time.
  // They may be used by Controls, since those are a more advanced feature of SVGA.
  Take(["RAF", "SVG"], function(RAF, SVG) {
    var TRS;
    TRS = function(elm, debugColor) {
      var v, wrapper;
      if (elm == null) {
        console.log(elm);
        throw new Error("^ Null element passed to TRS(elm)");
      }
      wrapper = SVG.create("g", elm.parentNode, {
        xTrs: ""
      });
      SVG.append(wrapper, elm);
      if (debugColor != null) {
        SVG.create("rect", wrapper, {
          class: "Debug",
          x: -2,
          y: -2,
          width: 4,
          height: 4,
          fill: debugColor
        });
      }
      elm._trs = v = {
        x: 0,
        y: 0,
        r: 0,
        sx: 1,
        sy: 1,
        ox: 0,
        oy: 0,
        apply: function() {
          SVG.attr(wrapper, "transform", `translate(${v.x},${v.y}) rotate(${v.r * 360}) scale(${v.sx},${v.sy})`);
          return SVG.attr(elm, "transform", `translate(${-v.ox},${-v.oy})`);
        }
      };
      return elm; // Composable
    };
    TRS.abs = function(elm, attrs) {
      var delta;
      if ((elm != null ? elm._trs : void 0) == null) {
        console.log(elm);
        throw new Error("^ Non-TRS element passed to TRS.abs(elm, attrs)");
      }
      if (attrs == null) {
        console.log(elm);
        throw new Error("^ Null attrs passed to TRS.abs(elm, attrs)");
      }
      if (attrs.scale != null) {
        // The order in which these are applied is super important.
        // If we change the order, it'll change the outcome of everything that uses this to do more than one operation per call.
        attrs.sx = attrs.sy = attrs.scale;
      }
      if (attrs.x != null) {
        elm._trs.x = attrs.x;
      }
      if (attrs.y != null) {
        elm._trs.y = attrs.y;
      }
      if (attrs.r != null) {
        elm._trs.r = attrs.r;
      }
      if (attrs.sx != null) {
        elm._trs.sx = attrs.sx;
      }
      if (attrs.sy != null) {
        elm._trs.sy = attrs.sy;
      }
      if (attrs.ox != null) {
        delta = attrs.ox - elm._trs.ox;
        elm._trs.ox = attrs.ox;
        elm._trs.x += delta;
      }
      if (attrs.oy != null) {
        delta = attrs.oy - elm._trs.oy;
        elm._trs.oy = attrs.oy;
        elm._trs.y += delta;
      }
      if (attrs.now) {
        elm._trs.apply();
      } else {
        RAF(elm._trs.apply, true, 1);
      }
      return elm; // Composable
    };
    TRS.rel = function(elm, attrs) {
      if ((elm != null ? elm._trs : void 0) == null) {
        console.log(elm);
        throw new Error("^ Non-TRS element passed to TRS.abs(elm, attrs)");
      }
      if (attrs == null) {
        console.log(elm);
        throw new Error("^ Null attrs passed to TRS.abs(elm, attrs)");
      }
      if (attrs.x != null) {
        // The order in which these are applied is super important.
        // If we change the order, it'll change the outcome of everything that uses this to do more than one operation per call.
        elm._trs.x += attrs.x;
      }
      if (attrs.y != null) {
        elm._trs.y += attrs.y;
      }
      if (attrs.r != null) {
        elm._trs.r += attrs.r;
      }
      if (attrs.sx != null) {
        elm._trs.sx += attrs.sx;
      }
      if (attrs.sy != null) {
        elm._trs.sy += attrs.sy;
      }
      if (attrs.ox != null) {
        elm._trs.ox += attrs.ox;
        elm._trs.x += attrs.ox;
      }
      if (attrs.oy != null) {
        elm._trs.oy += attrs.oy;
        elm._trs.y += attrs.oy;
      }
      if (attrs.now) {
        elm._trs.apply();
      } else {
        RAF(elm._trs.apply, true, 1);
      }
      return elm; // Composable
    };
    TRS.move = function(elm, x = 0, y = 0) {
      if (elm._trs == null) {
        console.log(elm);
        throw new Error("^ Non-TRS element passed to TRS.move");
      }
      return TRS.abs(elm, {
        x: x,
        y: y // Composable
      });
    };
    TRS.rotate = function(elm, r = 0) {
      if (elm._trs == null) {
        console.log(elm);
        throw new Error("^ Non-TRS element passed to TRS.rotate");
      }
      return TRS.abs(elm, {
        r: r // Composable
      });
    };
    TRS.scale = function(elm, sx = 1, sy = sx) {
      if (elm._trs == null) {
        console.log(elm);
        throw new Error("^ Non-TRS element passed to TRS.scale");
      }
      return TRS.abs(elm, {
        sx: sx,
        sy: sy // Composable
      });
    };
    TRS.origin = function(elm, ox = 0, oy = 0) {
      if (elm._trs == null) {
        console.log(elm);
        throw new Error("^ Non-TRS element passed to TRS.origin");
      }
      return TRS.abs(elm, {
        ox: ox,
        oy: oy // Composable
      });
    };
    return Make("TRS", TRS);
  });

}).call(this);
