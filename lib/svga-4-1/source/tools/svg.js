// Generated by CoffeeScript 2.7.0
(function() {
  // These are Ivan's SVG tools. They're private APIs, part of the implementation of SVGA.
  // They're not to be used by content, since they might endure breaking changes at any time.
  Take("DOMContentLoaded", function() {
    var CheckSVGReady, SVG, SVGReady, attrNames, defs, propNames, root, svg, svgNS, xlinkNS;
    
    // We give the main SVG an id in cd-core's gulpfile, so that we know which SVG to target.
    // There's only ever one SVGA in the current context, but there might be other SVGs
    // (eg: the header logo if this is a standalone deployed SVGA).
    // Also, we can't use getElementById because gulp-rev-all thinks it's a URL *facepalm*
    svg = document.querySelector("svg#svga");
    defs = svg.querySelector("defs");
    root = svg.getElementById("root");
    svgNS = "http://www.w3.org/2000/svg";
    xlinkNS = "http://www.w3.org/1999/xlink";
    
    // This is used to distinguish props from attrs, so we can set both with SVG.attr
    propNames = {
      textContent: true
    };
    // additional prop names will be listed here as needed

    // This is used to cache normalized keys, and to provide defaults for keys that shouldn't be normalized
    attrNames = {
      gradientUnits: "gradientUnits",
      viewBox: "viewBox",
      SCOPE: "SCOPE",
      SYMBOL: "SYMBOL"
    };
    // additional attr names will be listed here as needed

    // We want to wait until SVGReady fires before we change the structure of the DOM.
    // However, we can't just Take "SVGReady" at the top, because other systems want
    // to use these SVG tools in safe, non-structural ways before SVGReady has fired.
    // So we do this:
    SVGReady = false;
    CheckSVGReady = function() {
      return SVGReady || (SVGReady = Take("SVGReady"));
    };
    return Make("SVG", SVG = {
      svg: svg,
      defs: defs,
      root: root,
      create: function(type, parent, attrs) {
        var elm;
        elm = document.createElementNS(svgNS, type);
        if (attrs != null) {
          SVG.attrs(elm, attrs);
        }
        if (parent != null) {
          SVG.append(parent, elm);
        }
        return elm; // Composable
      },
      clone: function(source, parent, attrs) {
        var attr, child, elm, i, j, len, len1, ref, ref1;
        if (source == null) {
          throw new Error("Clone source is undefined in SVG.clone(source, parent, attrs)");
        }
        if (!CheckSVGReady()) {
          throw new Error("SVG.clone() called before SVGReady");
        }
        elm = document.createElementNS(svgNS, "g");
        ref = source.attributes;
        for (i = 0, len = ref.length; i < len; i++) {
          attr = ref[i];
          SVG.attr(elm, attr.name, attr.value);
        }
        SVG.attrs(elm, {
          id: null
        });
        if (attrs != null) {
          SVG.attrs(elm, attrs);
        }
        ref1 = source.childNodes;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          child = ref1[j];
          SVG.append(elm, child.cloneNode(true));
        }
        if (parent != null) {
          SVG.append(parent, elm);
        }
        return elm; // Composable
      },
      append: function(parent, child) {
        if (!CheckSVGReady()) {
          throw new Error("SVG.append() called before SVGReady");
        }
        parent.appendChild(child);
        return child; // Composable
      },
      prepend: function(parent, child) {
        if (!CheckSVGReady()) {
          throw new Error("SVG.prepend() called before SVGReady");
        }
        if (parent.hasChildNodes()) {
          parent.insertBefore(child, parent.firstChild);
        } else {
          parent.appendChild(child);
        }
        return child; // Composable
      },
      remove: function(parent, child) {
        if (!CheckSVGReady()) {
          throw new Error("SVG.remove() called before SVGReady");
        }
        parent.removeChild(child);
        return child;
      },
      removeAllChildren: function(parent) {
        var results;
        if (!CheckSVGReady()) {
          throw new Error("SVG.removeAllChildren() called before SVGReady");
        }
        results = [];
        while (parent.children.length > 0) {
          results.push(parent.removeChild(parent.firstChild));
        }
        return results;
      },
      attrs: function(elm, attrs) {
        var k, v;
        if (!elm) {
          throw new Error("SVG.attrs was called with a null element");
        }
        if (typeof attrs !== "object") {
          console.log(attrs);
          throw new Error("SVG.attrs requires an object as the second argument, got ^");
        }
        for (k in attrs) {
          v = attrs[k];
          SVG.attr(elm, k, v);
        }
        return elm; // Composable
      },
      attr: function(elm, k, v) {
        var base, ns;
        if (!elm) {
          throw new Error("SVG.attr was called with a null element");
        }
        if (typeof k !== "string") {
          console.log(k);
          throw new Error("SVG.attr requires a string as the second argument, got ^^^");
        }
        if (typeof v === "number" && isNaN(v)) {
          console.log(elm, k);
          throw new Error("SVG.attr was called with a NaN value for ^^^");
        }
        if (elm._SVG_attr == null) {
          elm._SVG_attr = {};
        }
        if (v === void 0) { // Read
          // Note that we only do DOM->cache on a read call (not on a write call),
          // to slightly avoid intermingling DOM reads and writes, which causes thrashing.
          return (base = elm._SVG_attr)[k] != null ? base[k] : base[k] = elm.getAttribute(k);
        }
        if (elm._SVG_attr[k] === v) { // cache hit â€” bail
          return v;
        }
        elm._SVG_attr[k] = v; // update cache
        if (propNames[k] != null) {
          return elm[k] = v;
        }
        ns = k === "xlink:href" ? xlinkNS : null;
        k = attrNames[k] != null ? attrNames[k] : attrNames[k] = k.replace(/([A-Z])/g, "-$1").toLowerCase(); // Normalize camelCase into kebab-case
        if (v != null) {
          elm.setAttributeNS(ns, k, v); // set DOM attribute
// v is explicitly set to null (not undefined)
        } else {
          elm.removeAttributeNS(ns, k); // remove DOM attribute
        }
        return v; // Not Composable
      },
      styles: function(elm, styles) {
        var k, v;
        if (!elm) {
          throw new Error("SVG.styles was called with a null element");
        }
        if (typeof styles !== "object") {
          console.log(styles);
          throw new Error("SVG.styles requires an object as the second argument, got ^");
        }
        for (k in styles) {
          v = styles[k];
          SVG.style(elm, k, v);
        }
        return elm; // Composable
      },
      style: function(elm, k, v) {
        var base;
        if (!elm) {
          throw new Error("SVG.style was called with a null element");
        }
        if (typeof k !== "string") {
          console.log(k);
          throw new Error("SVG.style requires a string as the second argument, got ^");
        }
        if (typeof v === "number" && isNaN(v)) {
          console.log(elm, k);
          throw new Error("SVG.style was called with a NaN value for ^^^");
        }
        if (elm._SVG_style == null) {
          elm._SVG_style = {};
        }
        if (v === void 0) {
          return (base = elm._SVG_style)[k] != null ? base[k] : base[k] = elm.style[k];
        }
        if (elm._SVG_style[k] !== v) {
          elm.style[k] = elm._SVG_style[k] = v;
        }
        return v; // Not Composable
      }
    });
  });

}).call(this);
