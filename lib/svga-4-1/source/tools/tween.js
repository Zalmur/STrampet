// Generated by CoffeeScript 2.7.0
(function() {
  // Keep this in sync with Tween in LBS
  Take(["Ease", "Tick"], function(Ease, Tick) {
    var Tween, clone, dist, gc, getEaseFn, getKeys, skipGC, timeScale, tweens;
    timeScale = 1;
    tweens = [];
    skipGC = false;
    Make("Tween", Tween = function(from, to, time, props = {}) {
      var k, keys, tween, v;
      // This object will hold all the state for this tween
      tween = {};
      // The 4th arg can be a tick function or an options object
      if (typeof props === "function") {
        tween.tick = props;
      } else {
// Copy to avoid mutating props, since we don't own it
        for (k in props) {
          v = props[k];
          tween[k] = v;
        }
      }
      
      // from/to can be numbers or objects. Internally, we'll work with objects.
      tween.multi = typeof from === "object";
      // If you don't provide a tick function, we'll assume we're mutating the from object.
      if (tween.mutate == null) {
        tween.mutate = tween.tick == null;
      }
      tween.keys = keys = tween.multi ? getKeys(to) : ["v"];
      tween.from = tween.multi ? clone(from, keys) : {
        v: from
      };
      tween.to = tween.multi ? clone(to, keys) : {
        v: to
      };
      tween.delta = dist(tween.from, tween.to, keys);
      tween.value = tween.mutate && tween.multi ? from : clone(tween.from, keys);
      tween.time = Math.max(0, time);
      tween.ease = getEaseFn(tween.ease);
      tween.pos = Math.min(1, tween.pos || 0);
      tween.delay = Math.max(0, tween.delay || 0);
      tween.completed = false;
      tween.cancelled = false;
      // Scale all time-affecting values
      tween.time *= timeScale;
      tween.pos *= timeScale;
      tween.delay *= timeScale;
      // Now is a great time to do some GC
      gc(tween.tick, tween.from);
      tweens.push(tween);
      return tween; // Composable
    });
    getKeys = function(o) {
      var k, results;
      results = [];
      for (k in o) {
        results.push(k);
      }
      return results;
    };
    clone = function(i, keys) {
      var j, k, len, o;
      o = {};
      for (j = 0, len = keys.length; j < len; j++) {
        k = keys[j];
        o[k] = i[k];
      }
      return o;
    };
    dist = function(from, to, keys) {
      var j, k, len, o;
      o = {};
      for (j = 0, len = keys.length; j < len; j++) {
        k = keys[j];
        o[k] = to[k] - from[k];
      }
      return o;
    };
    getEaseFn = function(given) {
      if (typeof given === "string") {
        return Ease[given] || (function() {
          throw new Error(`Tween: \"${given}\" is not a valid ease type.`);
        })();
      } else if (typeof given === "function") {
        return given;
      } else {
        return Ease.cubic;
      }
    };
    gc = function(tick, from) {
      if (skipGC) { // Don't GC if we're in the middle of a tick!
        return;
      }
      tweens = tweens.filter(function(tween) {
        if (tween.completed) {
          return false;
        }
        if (tween.cancelled) {
          return false;
        }
        if ((tick != null) && tick === tween.tick) { // this makes interruptions work normally
          return false;
        }
        if ((from != null) && from === tween.from) { // this makes interruptions work with mutate
          return false;
        }
        return true;
      });
      return null;
    };
    Tween.cancel = function(...tweensToCancel) {
      var j, len, tween;
      for (j = 0, len = tweensToCancel.length; j < len; j++) {
        tween = tweensToCancel[j];
        if (tween != null) {
          tween.cancelled = true;
        }
      }
      return gc(); // Aww sure, let's do a GC!
    };
    Tween.timeScale = function(ts) {
      if (ts != null) {
        timeScale = ts;
      }
      return timeScale;
    };
    return Tick(function(t, dt) {
      var e, j, k, l, len, len1, ref, remainingDt, tween, v;
      skipGC = true; // It's probably not safe to GC in the middle of our tick loop
      for (j = 0, len = tweens.length; j < len; j++) {
        tween = tweens[j];
        if (!(!tween.cancelled)) {
          continue;
        }
        remainingDt = dt;
        if (tween.delay > 0) {
          tween.delay -= dt;
          if (tween.delay < 0) {
            remainingDt = -tween.delay;
          }
        }
        if (tween.delay <= 0) {
          tween.pos = tween.time <= 0 ? 1 : Math.min(1, tween.pos + remainingDt / tween.time);
          e = tween.ease(tween.pos);
          ref = tween.keys;
          for (l = 0, len1 = ref.length; l < len1; l++) {
            k = ref[l];
            tween.value[k] = tween.from[k] + tween.delta[k] * e;
          }
          v = tween.multi ? tween.value : tween.value.v;
          if (typeof tween.tick === "function") {
            tween.tick(v, tween);
          }
          if (tween.completed = tween.pos === 1) {
            if (typeof tween.then === "function") {
              tween.then(v, tween);
            }
          }
        }
      }
      // Hey, another great time to do some GC!
      skipGC = false;
      return gc();
    });
  });

}).call(this);
