// Generated by CoffeeScript 2.7.0
(function() {
  Take(["Ease", "GUI", "Input", "SVG", "TRS", "Tween"], function(Ease, {
      Panel: GUI
    }, Input, SVG, TRS, Tween) {
    var SettingsSlider;
    return Make("SettingsSlider", SettingsSlider = function(elm, props) {
      var bgc, blueBG, handleDrag, label, labelPad, labelWidth, lightBG, lightDot, normalDot, orangeBG, range, snap, snapElms, snapTolerance, startDrag, strokeWidth, thumb, thumbSize, tickBG, toClicked, toClicking, toHover, toMissed, toNormal, track, trackWidth, update, updateSnaps, v;
      snapElms = [];
      v = 0;
      startDrag = 0;
      strokeWidth = 2;
      snapTolerance = 0.05;
      labelPad = 10;
      labelWidth = GUI.itemWidth / 2;
      trackWidth = GUI.itemWidth - labelWidth;
      thumbSize = GUI.unit;
      range = trackWidth - thumbSize;
      lightDot = "hsl(92, 46%, 57%)";
      normalDot = "hsl(220, 10%, 92%)";
      SVG.attrs(elm, {
        ui: true
      });
      track = SVG.create("rect", elm, {
        x: strokeWidth / 2 + labelWidth,
        y: strokeWidth / 2,
        width: trackWidth - strokeWidth,
        height: thumbSize - strokeWidth,
        strokeWidth: strokeWidth,
        fill: "hsl(227, 45%, 24%)",
        stroke: "hsl(227, 45%, 24%)",
        rx: thumbSize / 2
      });
      thumb = TRS(SVG.create("circle", elm, {
        cx: thumbSize / 2 + labelWidth,
        cy: thumbSize / 2,
        strokeWidth: strokeWidth,
        fill: "hsl(220, 10%, 92%)",
        r: thumbSize / 2 - strokeWidth / 2
      }));
      if (props.snaps != null) {
        snapElms = (function() {
          var j, len, ref, results;
          ref = props.snaps;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            snap = ref[j];
            results.push(SVG.create("circle", elm, {
              cx: thumbSize / 2 + labelWidth + (trackWidth - thumbSize) * snap,
              cy: thumbSize / 2,
              fill: "transparent",
              strokeWidth: 4
            }));
          }
          return results;
        })();
      }
      label = SVG.create("text", elm, {
        textContent: props.name,
        x: labelWidth - labelPad,
        y: 21,
        textAnchor: "end",
        fill: "hsl(220, 10%, 92%)"
      });
      // Setup the thumb stroke color for tweening
      bgc = blueBG = {
        r: 34,
        g: 46,
        b: 89
      };
      lightBG = {
        r: 133,
        g: 163,
        b: 224
      };
      orangeBG = {
        r: 255,
        g: 196,
        b: 46
      };
      tickBG = function(_bgc) {
        bgc = _bgc;
        return SVG.attrs(thumb, {
          stroke: `rgb(${bgc.r | 0},${bgc.g | 0},${bgc.b | 0})`
        });
      };
      tickBG(blueBG);
      updateSnaps = function(input) {
        var i, inMax, inMin, j, k, len, len1, outMax, outMin, ref, ref1;
        ref = props.snaps;
        // Reset all snaps
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          snap = ref[i];
          SVG.attrs(snapElms[i], {
            r: 2,
            stroke: normalDot
          });
        }
        ref1 = props.snaps;
        // Map our input to the right position, move the slider, and highlight the proper dot if needed
        for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
          snap = ref1[i];
          // Input is inside this snap point
          if (input >= snap - snapTolerance && input <= snap + snapTolerance) {
            SVG.attrs(snapElms[i], {
              r: 3,
              stroke: lightDot
            });
            TRS.abs(thumb, {
              x: snap * range
            });
            return snap;
          // Input is below this snap point
          } else if (input < snap - snapTolerance) {
            TRS.abs(thumb, {
              x: input * range
            });
            inMin = i > 0 ? props.snaps[i - 1] + snapTolerance : 0;
            inMax = snap - snapTolerance;
            outMin = i > 0 ? props.snaps[i - 1] : 0;
            outMax = snap;
            return Ease.linear(input, inMin, inMax, outMin, outMax);
          }
        }
        // Snap is above the last snap point
        TRS.abs(thumb, {
          x: input * range
        });
        inMin = props.snaps[props.snaps.length - 1] + snapTolerance;
        inMax = 1;
        outMin = props.snaps[props.snaps.length - 1];
        outMax = 1;
        return Ease.linear(input, inMin, inMax, outMin, outMax);
      };
      // Update and save the thumb position
      update = function(V) {
        if (V != null) {
          v = Math.max(0, Math.min(1, V));
        }
        if (props.snaps != null) {
          return v = updateSnaps(v);
        } else {
          return TRS.abs(thumb, {
            x: v * range
          });
        }
      };
      // Input event handling
      toNormal = function(e, state) {
        return Tween(bgc, blueBG, .2, {
          tick: tickBG
        });
      };
      toHover = function(e, state) {
        if (!state.touch) {
          return Tween(bgc, lightBG, 0, {
            tick: tickBG
          });
        }
      };
      toClicking = function(e, state) {
        return Tween(bgc, orangeBG, 0, {
          tick: tickBG
        });
      };
      toClicked = function(e, state) {
        return Tween(bgc, lightBG, .2, {
          tick: tickBG
        });
      };
      toMissed = function(e, state) {
        return Tween(bgc, blueBG, .2, {
          tick: tickBG
        });
      };
      handleDrag = function(e, state) {
        if (state.clicking) {
          update(e.clientX / range - startDrag);
          props.update(v);
          return void 0;
        }
      };
      Input(elm, {
        moveIn: toHover,
        dragIn: function(e, state) {
          if (state.clicking) {
            return toClicking();
          }
        },
        down: function(e) {
          toClicking();
          return startDrag = e.clientX / range - v;
        },
        moveOut: toNormal,
        miss: toMissed,
        drag: handleDrag,
        dragOther: handleDrag,
        click: toClicked
      });
      // Init
      return update(props.value || 0);
    });
  });

}).call(this);
