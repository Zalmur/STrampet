// Generated by CoffeeScript 2.7.0
(function() {
  Take(["GUI", "Mode", "SVG"], function({
      ControlPanel: GUI
    }, Mode, SVG) {
    var checkPanelSize, constructLayout;
    constructLayout = function(groups, desiredColumnHeight, vertical) {
      var column, columns, group, i, innerPanelSize, j, k, len, len1, len2, tallestColumnHeight;
      columns = [];
      column = null;

      // Whether we're in horizontal or vertical, our layout is built of columns.
// Controls may be grouped together with a color, and a color group is never split across columns.
      for (i = 0, len = groups.length; i < len; i++) {
        group = groups[i];
        
        // Start a new column if we need one
        if ((column == null) || column.height > desiredColumnHeight) {
          columns.push(column = {
            x: columns.length * (GUI.colInnerWidth + GUI.groupPad * 2 + GUI.columnMargin),
            y: 0, // This will be computed once we know how tall all our columns are
            height: 0,
            groups: []
          });
        }
        if (column.groups.length > 0) {
          
          // Add some margin between this group and the previous
          column.height += GUI.groupMargin;
        }
        
        // Attach this group to the column, and assign it a position
        column.groups.push({
          scope: group.scope,
          y: column.height
        });
        
        // Add this group's height to our running total
        column.height += group.height;
      }
      
      // Figure out which column is tallest, so we know how tall to make the panel
      tallestColumnHeight = 0;
      for (j = 0, len1 = columns.length; j < len1; j++) {
        column = columns[j];
        tallestColumnHeight = Math.max(tallestColumnHeight, column.height);
      }

      // Set the y position for each column
      for (k = 0, len2 = columns.length; k < len2; k++) {
        column = columns[k];
        // In vertical orientation, center-align
        // In horizontal orientation, bottom-align
        column.y = vertical ? tallestColumnHeight / 2 - column.height / 2 : tallestColumnHeight - column.height;
      }
      
      // Figure out how big to make the panel, so it fits all our columns
      innerPanelSize = {
        w: GUI.panelPadding * 2 + columns.length * (GUI.colInnerWidth + GUI.groupPad * 2) + (columns.length - 1) * GUI.columnMargin,
        h: GUI.panelPadding * 2 + tallestColumnHeight
      };
      return [innerPanelSize, columns];
    };
    Make("ControlPanelLayout", {
      vertical: function(groups, marginedSpace) {
        var desiredColumnHeight, desiredNumberOfColumns, group, i, len, maxHeight;
        if (!(marginedSpace.h > 0 && groups.length > 0)) { // Bail if the screen is too small or we have no controls
          return [
            {
              w: 0,
              h: 0
            },
            []
          ];
        }
        
        // First, get the height of the panel if it was just 1 column wide
        maxHeight = 0;
        for (i = 0, len = groups.length; i < len; i++) {
          group = groups[i];
          maxHeight += group.height;
        }
        maxHeight += GUI.groupMargin * (groups.length - 1); // Add padding between all groups
        
        // Figure out how many columns we need to fit this much height.
        desiredNumberOfColumns = Mode.embed ? 1 : Math.ceil(maxHeight / (marginedSpace.h - GUI.panelPadding * 2)); // If we're in embed mode, we'll force it to only ever have 1 column, because that's nicer.
        desiredColumnHeight = Math.max(GUI.unit, Math.floor(maxHeight / desiredNumberOfColumns));
        return constructLayout(groups, desiredColumnHeight, true);
      },
      horizontal: function(groups, marginedSpace) {
        var desiredColumnHeight;
        if (!(marginedSpace.w > 0 && groups.length > 0)) { // Bail if the screen is too small or we have no controls
          return [
            {
              w: 0,
              h: 0
            },
            []
          ];
        }
        desiredColumnHeight = GUI.unit / 2;
        
          // Increase the column height until everything fits on screen
        while (!checkPanelSize(desiredColumnHeight, groups, marginedSpace)) {
          desiredColumnHeight += GUI.unit / 4;
        }
        return constructLayout(groups, desiredColumnHeight, false);
      },
      applyLayout: function(columns, getColumnElm) {
        var c, column, columnElm, groupInfo, i, len, results;
        results = [];
        for (c = i = 0, len = columns.length; i < len; c = ++i) {
          column = columns[c];
          columnElm = getColumnElm(c);
          SVG.attrs(columnElm, {
            transform: `translate(${column.x},${column.y})`
          });
          results.push((function() {
            var j, len1, ref, results1;
            ref = column.groups;
            results1 = [];
            for (j = 0, len1 = ref.length; j < len1; j++) {
              groupInfo = ref[j];
              SVG.append(columnElm, groupInfo.scope.element);
              results1.push(groupInfo.scope.y = groupInfo.y);
            }
            return results1;
          })());
        }
        return results;
      }
    });
    return checkPanelSize = function(columnHeight, groups, marginedSpace) {
      var consumedHeight, consumedWidth, group, i, len, nthGroupInColumn;
      // We'll always have at least 1 column's worth of width, plus padding on both sides
      consumedWidth = GUI.colInnerWidth + GUI.panelPadding * 2;
      consumedHeight = GUI.panelPadding * 2;
      nthGroupInColumn = 0;
      for (i = 0, len = groups.length; i < len; i++) {
        group = groups[i];
        // Move to the next column if needed
        if (consumedHeight > columnHeight) {
          consumedWidth += GUI.colInnerWidth + GUI.columnMargin;
          consumedHeight = GUI.panelPadding * 2;
          nthGroupInColumn = 0;
        }
        if (nthGroupInColumn > 0) {
          consumedHeight += GUI.groupMargin;
        }
        // Add the current group height to our current column height
        consumedHeight += group.height;
        nthGroupInColumn++;
      }
      
      // We're done if we fit within the available width, or our column height gets out of hand
      return consumedWidth < marginedSpace.w || columnHeight > marginedSpace.h / 2;
    };
  });

}).call(this);
