// Generated by CoffeeScript 2.7.0
(function() {
  Take(["GUI", "Input", "PopoverButton", "RAF", "Registry", "Resize", "Scope", "SVG", "Tween"], function({
      ControlPanel: GUI
    }, Input, PopoverButton, RAF, Registry, Resize, Scope, SVG, Tween) {
    return Registry.set("Control", "popover", function(elm, props) {
      var activeButtonCancelCb, activeFill, activeLabel, bgc, blueBG, buttonContainer, buttons, controlPanelScale, desiredPanelX, desiredPanelY, height, input, itemElm, label, labelFill, labelHeight, labelTriangle, labelY, lightBG, nextButtonOffsetY, orangeBG, panel, panelInner, panelIsVertical, panelRect, panelTriangle, rect, rectFill, reposition, requestReposition, resize, scope, setActive, showing, strokeWidth, tickBG, toClicked, toClicking, toHover, toNormal, triangleFill, triangleSize, update, windowHeight;
      // Config
      labelFill = props.fontColor || "hsl(220, 10%, 92%)";
      rectFill = "hsl(227, 45%, 25%)";
      triangleFill = "hsl(220, 35%, 80%)";
      activeFill = "hsl(92, 46%, 57%)";
      triangleSize = 24;
      strokeWidth = 2;
      // State
      showing = false;
      panelIsVertical = true;
      buttons = [];
      nextButtonOffsetY = 0;
      activeButtonCancelCb = null;
      labelY = 0;
      labelHeight = 0;
      height = 0;
      desiredPanelX = null;
      desiredPanelY = null;
      controlPanelScale = null;
      windowHeight = null;
      // Init label size values
      if (props.name != null) {
        labelY = GUI.labelPad + (props.fontSize || 16) * 0.75; // Lato's baseline is about 75% down from the top of the caps
        labelHeight = GUI.labelPad + (props.fontSize || 16) * 1.2; // Lato's descenders are about 120% down from the top of the caps
      } else {
        labelHeight = 0;
      }
      height = labelHeight + GUI.unit;
      // This is the "item" in the main control panel
      itemElm = SVG.create("g", elm, {
        ui: true
      });
      if (props.name != null) {
        label = SVG.create("text", itemElm, {
          textContent: props.name,
          x: GUI.colInnerWidth / 2,
          y: labelY,
          fontSize: props.fontSize || 16,
          fontWeight: props.fontWeight || "normal",
          fontStyle: props.fontStyle || "normal",
          fill: labelFill
        });
      }
      rect = SVG.create("rect", itemElm, {
        rx: GUI.borderRadius + 2,
        fill: rectFill,
        x: 0,
        y: labelHeight,
        width: GUI.colInnerWidth,
        height: GUI.unit,
        strokeWidth: strokeWidth
      });
      activeLabel = SVG.create("text", itemElm, {
        y: labelHeight + 21,
        fill: activeFill
      });
      labelTriangle = SVG.create("polyline", itemElm, {
        points: "6,-6 13,0 6,6",
        transform: `translate(0, ${labelHeight + GUI.unit / 2})`,
        stroke: triangleFill,
        strokeWidth: 4,
        strokeLinecap: "round",
        fill: "none"
      });
      // This is the panel that pops open when you click the item
      panel = Scope(SVG.create("g", elm));
      panel.hide(0);
      panelTriangle = SVG.create("polyline", panel.element, {
        points: `0,${-triangleSize / 2} ${triangleSize * 4 / 7},0 0,${triangleSize / 2}`,
        fill: triangleFill
      });
      panelInner = SVG.create("g", panel.element);
      panelRect = SVG.create("rect", panelInner, {
        width: GUI.colInnerWidth,
        rx: GUI.panelBorderRadius,
        fill: triangleFill
      });
      buttonContainer = SVG.create("g", panelInner, {
        transform: `translate(${GUI.panelPadding},${GUI.panelPadding})`
      });
      resize = function() {
        if (panelIsVertical) {
          desiredPanelX = -GUI.colInnerWidth - 6;
          desiredPanelY = labelHeight + GUI.unit / 2 - nextButtonOffsetY / 2;
          SVG.attrs(panelTriangle, {
            transform: `translate(-7,${labelHeight + GUI.unit / 2})`
          });
        } else {
          desiredPanelX = 0;
          desiredPanelY = panelInner.y = -nextButtonOffsetY - triangleSize + labelHeight + 9;
          SVG.attrs(panelTriangle, {
            transform: `translate(${GUI.colInnerWidth / 2},${labelHeight - 7}) rotate(90)`
          });
        }
        SVG.attrs(panelInner, {
          transform: `translate(${desiredPanelX}, ${desiredPanelY})`
        });
        // We have to wait 1 tick for a layout operation to happen.
        // This causes some flickering, but I can't find a way to avoid that.
        return requestReposition();
      };
      requestReposition = function() {
        return RAF(reposition, true);
      };
      reposition = function() {
        var bounds, moveToBottom, moveToTop, newPanelY, offBottom, offTop, panelScale, tooTall;
        bounds = panelInner.getBoundingClientRect();
        tooTall = bounds.height > windowHeight - GUI.panelMargin * 2;
        offTop = bounds.top / controlPanelScale < GUI.panelMargin;
        offBottom = bounds.bottom / controlPanelScale > windowHeight - GUI.panelMargin;
        moveToTop = desiredPanelY - bounds.top / controlPanelScale + GUI.panelMargin;
        moveToBottom = desiredPanelY - (bounds.bottom / controlPanelScale) / controlPanelScale + (windowHeight - GUI.panelMargin);
        if (tooTall) {
          panelScale = Math.min(1, (windowHeight - GUI.panelMargin * 2) / bounds.height);
          newPanelY = moveToTop;
        } else if (offTop) {
          newPanelY = moveToTop;
          panelScale = 1;
        } else if (offBottom) {
          newPanelY = moveToBottom;
          panelScale = 1;
        } else {
          newPanelY = desiredPanelY;
          panelScale = 1;
        }
        return SVG.attrs(panelInner, {
          transform: `translate(${desiredPanelX * panelScale}, ${newPanelY}) scale(${panelScale})`
        });
      };
      setActive = function(buttonProps, unclick) {
        SVG.attrs(activeLabel, {
          textContent: buttonProps.name,
          fontSize: buttonProps.fontSize || 16,
          x: GUI.colInnerWidth / 2 + (name.length > 14 ? 8 : 0)
        });
        if (typeof activeButtonCancelCb === "function") {
          activeButtonCancelCb();
        }
        return activeButtonCancelCb = unclick;
      };
      // Setup the bg stroke color for tweening
      bgc = blueBG = {
        r: 34,
        g: 46,
        b: 89
      };
      lightBG = {
        r: 133,
        g: 163,
        b: 224
      };
      orangeBG = {
        r: 255,
        g: 196,
        b: 46
      };
      tickBG = function(_bgc) {
        bgc = _bgc;
        return SVG.attrs(rect, {
          stroke: `rgb(${bgc.r | 0},${bgc.g | 0},${bgc.b | 0})`
        });
      };
      tickBG(blueBG);
      update = function() {
        var button, i, len;
        if (showing) {
          panel.show(0);
          resize();
          for (i = 0, len = buttons.length; i < len; i++) {
            button = buttons[i];
            button.enable(true);
          }
        } else {
          panel.hide(0.2);
          requestAnimationFrame(function() {
            var j, len1, results;
            results = [];
            for (j = 0, len1 = buttons.length; j < len1; j++) {
              button = buttons[j];
              results.push(button.enable(false));
            }
            return results;
          });
        }
        return void 0;
      };
      // Input event handling
      toNormal = function(e, state) {
        return Tween(bgc, blueBG, .2, {
          tick: tickBG
        });
      };
      toHover = function(e, state) {
        if (!state.touch) {
          return Tween(bgc, lightBG, 0, {
            tick: tickBG
          });
        }
      };
      toClicking = function(e, state) {
        return Tween(bgc, orangeBG, 0, {
          tick: tickBG
        });
      };
      toClicked = function(e, state) {
        return Tween(bgc, lightBG, .2, {
          tick: tickBG
        });
      };
      input = Input(itemElm, {
        moveIn: toHover,
        dragIn: function(e, state) {
          if (state.clicking) {
            return toClicking();
          }
        },
        down: toClicking,
        up: toHover,
        moveOut: toNormal,
        dragOut: toNormal,
        upOther: function(e, state) {
          if (showing && !panel.element.contains(e.target)) {
            showing = false;
            return update();
          }
        },
        click: function() {
          showing = !showing;
          return update();
        }
      });
      Resize(function(info) {
        windowHeight = info.window.height;
        controlPanelScale = info.panel.scale;
        panelIsVertical = info.panel.vertical;
        desiredPanelY = null;
        return resize();
      });
      return scope = {
        height: height,
        input: input,
        close: function() {
          showing = false;
          return update();
        },
        open: function() {
          showing = true;
          return update();
        },
        toggle: function() {
          showing = !showing;
          return update();
        },
        button: function(props) {
          var buttonElm, buttonScope;
          props.setActive = setActive;
          buttonElm = SVG.create("g", buttonContainer);
          buttonScope = Scope(buttonElm, PopoverButton, props);
          buttons.push(buttonScope);
          buttonScope.y = nextButtonOffsetY;
          nextButtonOffsetY += GUI.unit + GUI.itemMargin;
          SVG.attrs(panelRect, {
            height: nextButtonOffsetY + GUI.panelPadding * 2 - GUI.itemMargin
          });
          return buttonScope;
        },
        _highlight: function(enable) {
          if (enable) {
            SVG.attrs(label, {
              fill: "url(#LightHighlightGradient)"
            });
            SVG.attrs(activeLabel, {
              fill: "url(#LightHighlightGradient)"
            });
            SVG.attrs(labelTriangle, {
              stroke: "url(#LightHighlightGradient)"
            });
            SVG.attrs(panelTriangle, {
              fill: "url(#LightHighlightGradient)"
            });
            SVG.attrs(panelRect, {
              fill: "url(#LightHighlightGradient)"
            });
            return SVG.attrs(rect, {
              fill: "url(#DarkHighlightGradient)"
            });
          } else {
            SVG.attrs(label, {
              fill: labelFill
            });
            SVG.attrs(activeLabel, {
              fill: activeFill
            });
            SVG.attrs(labelTriangle, {
              stroke: triangleFill
            });
            SVG.attrs(panelTriangle, {
              fill: triangleFill
            });
            SVG.attrs(panelRect, {
              fill: triangleFill
            });
            return SVG.attrs(rect, {
              fill: rectFill
            });
          }
        }
      };
    });
  });

}).call(this);
