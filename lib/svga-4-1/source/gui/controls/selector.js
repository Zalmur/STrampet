// Generated by CoffeeScript 2.7.0
(function() {
  Take(["Registry", "GUI", "SelectorButton", "Scope", "SVG"], function(Registry, {
      ControlPanel: GUI
    }, SelectorButton, Scope, SVG) {
    var idCounter;
    idCounter = 0;
    return Registry.set("Control", "selector", function(elm, props) {
      var activeButton, borderFill, borderRect, buttons, buttonsContainer, clip, clipRect, height, id, label, labelFill, labelHeight, labelY, scope, setActive;
      id = `Selector${idCounter++}`;
      buttons = [];
      activeButton = null;
      if (props.name != null) {
        // Remember: SVG text element position is ALWAYS relative to the text baseline.
        // So, we position our baseline a certain distance from the top, based on the font size.
        labelY = GUI.labelPad + (props.fontSize || 16) * 0.75; // Lato's baseline is about 75% down from the top of the caps
        labelHeight = GUI.labelPad + (props.fontSize || 16) * 1.2; // Lato's descenders are about 120% down from the top of the caps
      } else {
        labelHeight = 0;
      }
      height = labelHeight + GUI.unit;
      labelFill = props.fontColor || "hsl(220, 10%, 92%)";
      borderFill = "rgb(34, 46, 89)";
      clip = SVG.create("clipPath", SVG.defs, {
        id: id
      });
      clipRect = SVG.create("rect", clip, {
        x: 2,
        y: 2,
        width: GUI.colInnerWidth - 4,
        height: GUI.unit - 4,
        rx: GUI.borderRadius,
        fill: "#FFF"
      });
      if (props.name != null) {
        label = SVG.create("text", elm, {
          textContent: props.name,
          x: GUI.colInnerWidth / 2,
          y: labelY,
          fontSize: props.fontSize || 16,
          fontWeight: props.fontWeight || "normal",
          fontStyle: props.fontStyle || "normal",
          fill: labelFill
        });
      }
      borderRect = SVG.create("rect", elm, {
        rx: GUI.borderRadius + 2,
        fill: borderFill,
        x: 0,
        y: labelHeight,
        width: GUI.colInnerWidth,
        height: GUI.unit
      });
      buttonsContainer = Scope(SVG.create("g", elm, {
        clipPath: `url(#${id})`
      }));
      buttonsContainer.x = 0;
      buttonsContainer.y = labelHeight;
      setActive = function(unclick) {
        if (typeof activeButton === "function") {
          activeButton();
        }
        return activeButton = unclick;
      };
      return scope = {
        height: height,
        button: function(props) {
          var button, buttonElm, buttonScope, buttonWidth, i, j, len;
          props.setActive = setActive;
          // We check for this property in some control-specific scope-processors
          props._isControl = true;
          buttonElm = SVG.create("g", buttonsContainer.element);
          buttonScope = Scope(buttonElm, SelectorButton, props);
          buttons.push(buttonScope);
          // We don't want controls to highlight when they're hovered over,
          // so we flag them in a way that highlight can see.
          buttonScope._dontHighlightOnHover = true;
          buttonWidth = GUI.colInnerWidth / buttons.length;
          for (i = j = 0, len = buttons.length; j < len; i = ++j) {
            button = buttons[i];
            button.resize(buttonWidth);
            button.x = buttonWidth * i;
          }
          return buttonScope;
        },
        _highlight: function(enable) {
          var button, j, len, results;
          if (enable) {
            if (label != null) {
              SVG.attrs(label, {
                fill: "url(#LightHighlightGradient)"
              });
            }
            SVG.attrs(borderRect, {
              fill: "url(#DarkHighlightGradient)"
            });
          } else {
            if (label != null) {
              SVG.attrs(label, {
                fill: labelFill
              });
            }
            SVG.attrs(borderRect, {
              fill: borderFill
            });
          }
          results = [];
          for (j = 0, len = buttons.length; j < len; j++) {
            button = buttons[j];
            results.push(button._highlight(enable));
          }
          return results;
        }
      };
    });
  });

}).call(this);
