// Generated by CoffeeScript 2.7.0
(function() {
  Take(["Ease", "GUI", "Input", "Registry", "SVG", "TRS", "Tween"], function(Ease, {
      ControlPanel: GUI
    }, Input, Registry, SVG, TRS, Tween) {
    return Registry.set("Control", "slider", function(elm, props) {
      var bgc, blueBG, changeHandlers, downHandlers, handleDown, handleDrag, handleUp, height, hit, input, inputCalls, label, labelFill, labelHeight, labelY, leftLabel, lightBG, lightDot, normalDot, orangeBG, range, rightLabel, scope, snap, snapElms, snapTolerance, startDrag, strokeWidth, thumb, thumbBGFill, thumbSize, tickBG, toClicked, toClicking, toHover, toMissed, toNormal, track, trackFill, upHandlers, update, updateSnaps, v;
      // An array to hold all the callbacks that have been attached to this slider
      changeHandlers = [];
      downHandlers = [];
      upHandlers = [];
      snapElms = [];
      // Some local variables used to manage the slider position
      v = 0;
      startDrag = 0;
      strokeWidth = 2;
      snapTolerance = 0.033;
      if (props.name != null) {
        // Remember: SVG text element position is ALWAYS relative to the text baseline.
        // So, we position our baseline a certain distance from the top, based on the font size.
        labelY = GUI.labelPad + (props.fontSize || 16) * 0.75; // Lato's baseline is about 75% down from the top of the caps
        labelHeight = GUI.labelPad + (props.fontSize || 16) * 1.2; // Lato's descenders are about 120% down from the top of the caps
      } else {
        labelHeight = 0;
      }
      thumbSize = GUI.thumbSize;
      height = labelHeight + thumbSize;
      range = GUI.colInnerWidth - thumbSize;
      trackFill = "hsl(227, 45%, 24%)";
      thumbBGFill = "hsl(220, 10%, 92%)";
      labelFill = props.fontColor || "hsl(220, 10%, 92%)";
      lightDot = "hsl(92, 46%, 57%)";
      normalDot = "hsl(220, 10%, 92%)";
      // Enable pointer cursor, other UI features
      SVG.attrs(elm, {
        ui: true
      });
      hit = SVG.create("rect", elm, {
        width: GUI.colInnerWidth,
        height: height,
        fill: "transparent"
      });
      // Slider background element
      track = TRS(SVG.create("rect", elm, {
        x: strokeWidth / 2,
        y: labelHeight + strokeWidth / 2,
        width: GUI.colInnerWidth - strokeWidth,
        height: thumbSize - strokeWidth,
        strokeWidth: strokeWidth,
        fill: trackFill,
        stroke: "hsl(227, 45%, 24%)",
        rx: thumbSize / 2
      }));
      // The labels for left and right ends
      if (props.leftLabel != null) {
        leftLabel = SVG.create("text", elm, {
          textContent: props.leftLabel.toUpperCase(),
          x: strokeWidth + 5,
          y: labelHeight + thumbSize / 2 + 3,
          fontSize: 10,
          textAnchor: "start",
          fill: "hsl(220, 25%, 75%)"
        });
      }
      if (props.rightLabel != null) {
        rightLabel = SVG.create("text", elm, {
          textContent: props.rightLabel.toUpperCase(),
          x: GUI.colInnerWidth - strokeWidth - 5,
          y: labelHeight + thumbSize / 2 + 3,
          fontSize: 10,
          textAnchor: "end",
          fill: "hsl(220, 25%, 75%)"
        });
      }
      // The thumb graphic
      thumb = TRS(SVG.create("circle", elm, {
        cx: thumbSize / 2,
        cy: labelHeight + thumbSize / 2,
        strokeWidth: strokeWidth,
        fill: thumbBGFill,
        r: thumbSize / 2 - strokeWidth / 2
      }));
      if (props.snaps != null) {
        snapElms = (function() {
          var j, len, ref, results;
          ref = props.snaps;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            snap = ref[j];
            results.push(SVG.create("circle", elm, {
              cx: thumbSize / 2 + (GUI.colInnerWidth - thumbSize) * snap,
              cy: labelHeight + thumbSize / 2,
              fill: "transparent",
              strokeWidth: 4
            }));
          }
          return results;
        })();
      }
      // The text label
      if (props.name != null) {
        label = SVG.create("text", elm, {
          textContent: props.name,
          x: GUI.colInnerWidth / 2,
          y: labelY,
          fontSize: props.fontSize || 16,
          fontWeight: props.fontWeight || "normal",
          fontStyle: props.fontStyle || "normal",
          fill: labelFill
        });
      }
      // Setup the thumb stroke color for tweening
      bgc = blueBG = {
        r: 34,
        g: 46,
        b: 89
      };
      lightBG = {
        r: 133,
        g: 163,
        b: 224
      };
      orangeBG = {
        r: 255,
        g: 196,
        b: 46
      };
      tickBG = function(_bgc) {
        bgc = _bgc;
        return SVG.attrs(thumb, {
          stroke: `rgb(${bgc.r | 0},${bgc.g | 0},${bgc.b | 0})`
        });
      };
      tickBG(blueBG);
      updateSnaps = function(input) {
        var i, inMax, inMin, j, k, len, len1, outMax, outMin, ref, ref1;
        ref = props.snaps;
        // Reset all snaps
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          snap = ref[i];
          SVG.attrs(snapElms[i], {
            r: 2,
            stroke: normalDot
          });
        }
        ref1 = props.snaps;
        // Map our input to the right position, move the slider, and highlight the proper dot if needed
        for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
          snap = ref1[i];
          // Input is inside this snap point
          if (input >= snap - snapTolerance && input <= snap + snapTolerance) {
            SVG.attrs(snapElms[i], {
              r: 3,
              stroke: lightDot
            });
            TRS.abs(thumb, {
              x: snap * range
            });
            return snap;
          // Input is below this snap point
          } else if (input < snap - snapTolerance) {
            TRS.abs(thumb, {
              x: input * range
            });
            inMin = i > 0 ? props.snaps[i - 1] + snapTolerance : 0;
            inMax = snap - snapTolerance;
            outMin = i > 0 ? props.snaps[i - 1] : 0;
            outMax = snap;
            return Ease.linear(input, inMin, inMax, outMin, outMax);
          }
        }
        // Snap is above the last snap point
        TRS.abs(thumb, {
          x: input * range
        });
        inMin = props.snaps[props.snaps.length - 1] + snapTolerance;
        inMax = 1;
        outMin = props.snaps[props.snaps.length - 1];
        outMax = 1;
        return Ease.linear(input, inMin, inMax, outMin, outMax);
      };
      // Update and save the thumb position
      update = function(V) {
        if (V != null) {
          v = Math.max(0, Math.min(1, V));
        }
        if (props.snaps != null) {
          return v = updateSnaps(v);
        } else {
          return TRS.abs(thumb, {
            x: v * range
          });
        }
      };
      update(props.value || 0);
      // Input event handling
      toNormal = function(e, state) {
        return Tween(bgc, blueBG, .2, {
          tick: tickBG
        });
      };
      toHover = function(e, state) {
        if (!state.touch) {
          return Tween(bgc, lightBG, 0, {
            tick: tickBG
          });
        }
      };
      toClicking = function(e, state) {
        return Tween(bgc, orangeBG, 0, {
          tick: tickBG
        });
      };
      toClicked = function(e, state) {
        return Tween(bgc, lightBG, .2, {
          tick: tickBG
        });
      };
      toMissed = function(e, state) {
        return Tween(bgc, blueBG, .2, {
          tick: tickBG
        });
      };
      handleDown = function(e, state) {
        var downHandler, j, len;
        startDrag = e.clientX / range - v;
        for (j = 0, len = downHandlers.length; j < len; j++) {
          downHandler = downHandlers[j];
          downHandler(v);
        }
        return void 0;
      };
      handleDrag = function(e, state) {
        var changeHandler, j, len;
        if (state.clicking) {
          update(e.clientX / range - startDrag);
          for (j = 0, len = changeHandlers.length; j < len; j++) {
            changeHandler = changeHandlers[j];
            changeHandler(v);
          }
          return void 0;
        }
      };
      handleUp = function(e, state) {
        var j, len, upHandler;
        for (j = 0, len = upHandlers.length; j < len; j++) {
          upHandler = upHandlers[j];
          upHandler(v);
        }
        return void 0;
      };
      inputCalls = {
        moveIn: toHover,
        dragIn: function(e, s) {
          if (s.clicking) {
            return toClicking();
          }
        },
        down: function(e, s) {
          toClicking(e, s);
          return handleDown(e, s);
        },
        moveOut: toNormal,
        miss: function(e, s) {
          toMissed(e, s);
          return handleUp(e, s);
        },
        drag: handleDrag,
        dragOther: handleDrag,
        click: function(e, s) {
          toClicked(e, s);
          return handleUp(e, s);
        }
      };
      input = Input(elm, inputCalls, true, true, {
        blockScroll: true
      });
      return scope = {
        height: height,
        input: input,
        setValue: function(v, runHandlers = true) {
          var changeHandler, j, len;
          update(v);
          if (runHandlers) {
            for (j = 0, len = changeHandlers.length; j < len; j++) {
              changeHandler = changeHandlers[j];
              changeHandler(v);
            }
          }
          return void 0;
        },
        attach: function(props) {
          if (props.change != null) {
            changeHandlers.push(props.change);
          }
          if (props.down != null) {
            downHandlers.push(props.down);
          }
          if (props.up != null) {
            upHandlers.push(props.up);
          }
          if (props.value != null) {
            return update(props.value);
          }
        },
        _highlight: function(enable) {
          if (enable) {
            SVG.attrs(track, {
              fill: "url(#DarkHighlightGradient)"
            });
            SVG.attrs(thumb, {
              fill: "url(#LightHighlightGradient)"
            });
            return SVG.attrs(label, {
              fill: "url(#LightHighlightGradient)"
            });
          } else {
            SVG.attrs(track, {
              fill: trackFill
            });
            SVG.attrs(thumb, {
              fill: thumbBGFill
            });
            return SVG.attrs(label, {
              fill: labelFill
            });
          }
        }
      };
    });
  });

}).call(this);
