// Generated by CoffeeScript 2.7.0
(function() {
  Take(["FlowArrows:Config", "Vec"], function(Config, Vec) {
    var cullInlinePoints, cullShortEdges, cullShortSegments, formSegments, isConnected, isInline, joinSegments, log, reifySegments, reifyVectors, wrap;
    // PROCESSING STEPS ##############################################################################
    log = function(a) {
      console.dir(a);
      return a;
    };
    formSegments = function(lineData) {
      var i, k, pointA, pointB, ref, segmentEdges, segments;
      segments = []; // array of segments
      segmentEdges = null; // array of edges in the current segment

      // loop in pairs, since lineData is alternating start/end points of edges
      for (i = k = 0, ref = lineData.length; k < ref; i = k += 2) {
        pointA = lineData[i];
        pointB = lineData[i + 1];
        // if we're already making a segment, and the new edge is a continuation of the last edge
        if ((segmentEdges != null) && isConnected(pointA, segmentEdges[segmentEdges.length - 1])) {
          segmentEdges.push(pointB); // this edge is a continuation of the last edge
        } else if ((segmentEdges != null) && isConnected(pointB, segmentEdges[segmentEdges.length - 1])) {
          segmentEdges.push(pointA); // this edge is a continuation of the last edge
        
        // if we're already making a segment, and the new edge comes before the first edge
        } else if ((segmentEdges != null) && isConnected(segmentEdges[0], pointB)) {
          segmentEdges.unshift(pointA); // the first edge is a continuation of this edge
        } else if ((segmentEdges != null) && isConnected(segmentEdges[0], pointA)) {
          segmentEdges.unshift(pointB); // the first edge is a continuation of this edge
        } else {
          
          // we're not yet making a segment, or the new edge isn't connected to the current segment
          segments.push(segmentEdges = [
            pointA,
            pointB // this edge is for a new segment
          ]);
        }
      }
      return segments;
    };
    joinSegments = function(segments) {
      var i, j, pointA, pointB, segA, segB;
      segA = null;
      segB = null;
      pointA = null;
      pointB = null;
      i = segments.length;
      while (i--) {
        j = segments.length;
        while (--j > i) {
          segA = segments[i];
          segB = segments[j];
          pointA = segA[0];
          pointB = segB[0];
          if (isConnected(pointA, pointB)) {
            // they're connected startA-to-startB, so flip B and merge B->A
            segB.reverse();
            segB.pop();
            segments[i] = segB.concat(segA);
            segments.splice(j, 1);
            continue;
          }
          // test the two segment ends
          pointA = segA[segA.length - 1];
          pointB = segB[segB.length - 1];
          if (isConnected(pointA, pointB)) {
            // they're connected endA-to-endB, so flip B and merge A->B
            segB.reverse();
            segB.unshift();
            segments[i] = segA.concat(segB);
            segments.splice(j, 1);
            continue;
          }
          // test endA-to-startB
          pointA = segA[segA.length - 1];
          pointB = segB[0];
          if (isConnected(pointA, pointB)) {
            // they're connected endA-to-startB, so merge A->B
            segments[i] = segA.concat(segB);
            segments.splice(j, 1);
            continue;
          }
          // test startA-to-endB
          pointA = segA[0];
          pointB = segB[segB.length - 1];
          if (isConnected(pointA, pointB)) {
            // they're connected startA-to-endB, so merge B->A
            segments[i] = segB.concat(segA);
            segments.splice(j, 1);
            continue;
          }
        }
      }
      return segments;
    };
    cullShortEdges = function(segments) {
      var i, j, pointA, pointB, seg;
      i = segments.length;
      seg = [];
      pointA = pointB = null;
      while (i--) {
        seg = segments[i];
        j = seg.length - 1;
        while (j-- > 0) {
          pointA = seg[j];
          pointB = seg[j + 1];
          if (Vec.distance(pointA, pointB) < Config.MIN_EDGE_LENGTH) {
            pointA.cull = true;
          }
        }
      }
      i = segments.length;
      while (i--) {
        seg = segments[i];
        j = seg.length - 1;
        while (j-- > 0) {
          if (seg[j].cull) {
            seg.splice(j, 1);
          }
        }
      }
      return segments;
    };
    cullInlinePoints = function(segments) {
      var i, j, pointA, pointB, pointC, seg;
      seg = [];
      pointA = null;
      pointB = null;
      pointC = null;
      // find all points that are inline with the points on either side of it, and cull them
      i = segments.length;
      while (i--) {
        seg = segments[i];
        j = seg.length - 2;
        while (j-- > 0 && seg.length > 2) {
          pointA = seg[j];
          pointB = seg[j + 1];
          pointC = seg[j + 2];
          if (isInline(pointA, pointB, pointC)) {
            seg.splice(j + 1, 1);
          }
        }
      }
      return segments;
    };
    reifyVectors = function(segments) {
      var i, k, len, pointA, pointB, results, segment, vector;
      results = [];
      for (k = 0, len = segments.length; k < len; k++) {
        segment = segments[k];
        results.push((function() {
          var l, len1, results1;
          results1 = [];
          for (i = l = 0, len1 = segment.length; l < len1; i = ++l) {
            pointA = segment[i];
            if (pointB = segment[i + 1]) {
              results1.push(vector = {
                x: pointA.x,
                y: pointA.y,
                dist: Vec.distance(pointA, pointB),
                angle: Vec.angle(pointA, pointB)
              });
            }
          }
          return results1;
        })());
      }
      return results;
    };
    reifySegments = function(set) {
      var dist, k, l, len, len1, results, segment, segmentVectors, vector;
      results = [];
      for (k = 0, len = set.length; k < len; k++) {
        segmentVectors = set[k];
        dist = 0;
        for (l = 0, len1 = segmentVectors.length; l < len1; l++) {
          vector = segmentVectors[l];
          dist += vector.dist;
        }
        results.push(segment = {
          vectors: segmentVectors,
          dist: dist
        });
      }
      return results;
    };
    cullShortSegments = function(set) {
      return set.filter(function(segment) {
        return segment.dist >= Config.MIN_SEGMENT_LENGTH;
      });
    };
    // HELPERS #######################################################################################
    wrap = function(data) {
      return {
        process: function(fn) {
          return wrap(fn(data));
        },
        result: data
      };
    };
    isConnected = function(a, b) {
      var dX, dY;
      dX = Math.abs(a.x - b.x);
      dY = Math.abs(a.y - b.y);
      return dX < Config.CONNECTED_DISTANCE && dY < Config.CONNECTED_DISTANCE;
    };
    isInline = function(a, b, c) {
      var crossproduct, dotproduct, squaredlengthba;
      crossproduct = (c.y - a.y) * (b.x - a.x) - (c.x - a.x) * (b.y - a.y);
      if (Math.abs(crossproduct) > 0.01) {
        return false;
      }
      dotproduct = (c.x - a.x) * (b.x - a.x) + (c.y - a.y) * (b.y - a.y);
      if (dotproduct < 0) {
        return false;
      }
      squaredlengthba = (b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y);
      if (dotproduct > squaredlengthba) {
        return false;
      }
      return true;
    };
    // MAIN ##########################################################################################
    return Make("FlowArrows:Process", function(lineData) {
      return wrap(lineData).process(formSegments).process(joinSegments).process(cullShortEdges).process(cullInlinePoints).process(reifyVectors).process(reifySegments).process(cullShortSegments).result; // Wrap our data into a format suitable for the below processing pipeline // organize the points into an array of segment groups // combine segments that are visibly connected but whose points were listed in the wrong order // remove points that constitute an unusably short edge // remove points that lie on a line // create vectors with a position, dist, and angle // create segments with a dist and edges // remove vectors that are unusably short // return the result after all the above processing steps
    });
  });

}).call(this);
