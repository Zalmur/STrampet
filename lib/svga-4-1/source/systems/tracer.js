// Generated by CoffeeScript 2.7.0
(function() {
  var indexOf = [].indexOf;

  Take(["Control", "Panel", "Reaction", "Resize", "SVG", "Scope", "Tick", "Tween", "Vec", "Wait"], function(Control, Panel, Reaction, Resize, SVG, Scope, Tick, Tween, Vec, Wait) {
    var Nav, Tracer, activeConfig, buildBadge, buildGlow, buildHit, cancelClick, checkForFirstMistakeEver, checkForIncorrectPaths, checkForWin, checkShape, clickPath, cloneChild, createTracerProp, delayedMistakePath, editClick, editing, editingSetupDone, eventInside, gameClick, getFullPathId, getIncorrectPaths, getReaction, hitMoveIn, hitMoveOut, hoveredPath, incPath, lastScale, noMistakesEver, resetTracerProp, saveConfiguration, scorePath, setPathClickPos, setupEditing, setupPathEvents, setupPaths, setupSolutionSet, stableCounter, startClick, stylePath, unstylePath, updateBadge, updateZoomScaling, xShape;
    // Nav doesn't exist until after Symbol registration closes, so if we added it to Take,
    // Symbols (like root, in the animation code) wouldn't be able to take Tracer.
    Nav = null;
    Take("Nav", function(N) {
      return Nav = N;
    });
    activeConfig = null;
    hoveredPath = null;
    editing = false;
    xShape = "M-1,-1 L1,1 M-1,1 L1,-1";
    checkShape = "M-1,0 L-.3,.8 L1,-1";
    // HELPERS #########################################################################################
    getFullPathId = function(path) {
      var fullId, parent;
      fullId = path.id;
      parent = path.parent;
      while ((parent != null) && parent.id !== "root") {
        fullId = parent.id + "." + fullId;
        parent = parent.parent;
      }
      return `@${fullId}`;
    };
    cloneChild = function(path, child) {
      var elm;
      elm = child.element.cloneNode(true);
      path.element.appendChild(elm);
      return elm;
    };
    eventInside = function(e) {
      var ref;
      if (((ref = e.touches) != null ? ref.length : void 0) > 0) {
        e = e.touches[0];
      }
      return e.target === document.body || e.target === SVG.svg || SVG.root.contains(e.target);
    };
    // SETUP #########################################################################################
    setupPaths = function() {
      var j, k, l, len, len1, len2, path, ref, ref1, ref2, set, setIndex;
      ref = activeConfig.paths;
      for (j = 0, len = ref.length; j < len; j++) {
        path = ref[j];
        if (path == null) {
          throw "One of the paths given to Tracer is null";
        }
        if (path.tracer == null) {
          setupPathEvents(path);
          createTracerProp(path);
        }
        resetTracerProp(path);
      }
      ref1 = activeConfig.solution;
      for (setIndex = k = 0, len1 = ref1.length; k < len1; setIndex = ++k) {
        set = ref1[setIndex];
        setupSolutionSet(set, setIndex);
      }
      ref2 = activeConfig.paths;
      for (l = 0, len2 = ref2.length; l < len2; l++) {
        path = ref2[l];
        stylePath(path);
      }
      return updateZoomScaling(true, true);
    };
    setupPathEvents = function(path) {
      var cancel, click, start;
      // TODO: The move and up events need to go on window
      // Maybe we do a single listener on window that just handles drag distance,
      // and then a down and up handler on each element checks whether we should click it
      start = startClick(path);
      cancel = cancelClick(path);
      click = clickPath(path);
      path.element.addEventListener("mousedown", start);
      path.element.addEventListener("mousemove", cancel);
      path.element.addEventListener("mouseup", click);
      path.element.addEventListener("touchstart", start);
      path.element.addEventListener("touchmove", cancel);
      return path.element.addEventListener("touchend", click); // Hack: Input touchend preventDefault blocks click
    };
    createTracerProp = function(path) {
      var child;
      return path.tracer = {
        originalChildren: Array.from(path.element.children),
        glows: (function() {
          var j, len, ref, results;
          ref = path.children;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            child = ref[j];
            results.push(buildGlow(path, child));
          }
          return results;
        })(),
        hits: (function() {
          var j, len, ref, results;
          ref = path.children;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            child = ref[j];
            results.push(buildHit(path, child));
          }
          return results;
        })(),
        badge: buildBadge(path)
      };
    };
    // Not sure if we need this anymore, and it causes a layout/paint
    // bb: path.children[0].element.getBBox()
    resetTracerProp = function(path) {
      path.tracer.clicking = false;
      path.tracer.hovering = false;
      path.tracer.clickCount = 0;
      path.tracer.desiredClicks = 0;
      path.tracer.clickPos = null;
      path.tracer.animstate = null;
      path.tracer.isCorrect = true;
      path.tracer.isMistake = false;
      path.tracer.tween = null;
      return path.tracer.badge.alpha = false;
    };
    buildGlow = function(path, child) {
      var scope;
      scope = Scope(cloneChild(path, child));
      scope.strokeWidth = 3;
      scope.strokeLinejoin = "round";
      scope.strokeLinecap = "round";
      return scope;
    };
    buildHit = function(path, child) {
      var scope;
      scope = Scope(cloneChild(path, child));
      scope.strokeWidth = 10;
      scope.strokeLinejoin = "round";
      scope.strokeLinecap = "round";
      scope.element.addEventListener("mouseenter", hitMoveIn(path));
      scope.element.addEventListener("mouseleave", hitMoveOut(path));
      return scope;
    };
    buildBadge = function(path) {
      var scope;
      // The transform on this element is used to put it in the right position
      scope = Scope(SVG.create("g", path.element, {
        class: "tracer-badge",
        fill: "none",
        strokeLinecap: "round"
      }));
      scope.alpha = false;
      // The transform on this element is used for zoom-based scaling
      scope.zoomScale = SVG.create("g", scope.element);
      scope.shadow = SVG.create("path", scope.zoomScale, {
        strokeWidth: 1,
        stroke: "white"
      });
      scope.shape = SVG.create("path", scope.zoomScale, {
        strokeWidth: .5
      });
      return scope;
    };
    setupSolutionSet = function(set, setIndex) {
      var colorIndex, j, len, path, results;
      colorIndex = setIndex + 1;
      results = [];
      for (j = 0, len = set.length; j < len; j++) {
        path = set[j];
        path.tracer.desiredClicks = colorIndex;
        if (editing) {
          path.tracer.clickCount = colorIndex;
        }
        path.tracer.isCorrect = false;
        // Sort this wire to the top, so that it's easier to click on than unused wires
        results.push(path.element.parentNode.appendChild(path.element));
      }
      return results;
    };
    // ZOOM-BASED SCALING ############################################################################
    lastScale = null;
    stableCounter = 10;
    Reaction("Nav", function() {
      var scale;
      if (activeConfig == null) {
        return;
      }
      scale = Nav.rootScale();
      if (scale !== lastScale) {
        lastScale = scale;
        stableCounter = 0;
        return updateZoomScaling(false, true);
      }
    });
    Tick(function() {
      var scale;
      if (!((activeConfig != null) && (stableCounter != null))) {
        return;
      }
      scale = Nav.rootScale();
      stableCounter++;
      if (stableCounter >= 10) {
        stableCounter = null;
        return updateZoomScaling(true, false);
      }
    });
    updateZoomScaling = function(updateHits, updateBadges) {
      var badgeScale, hit, hitScale, j, k, len, len1, path, ref, ref1, scale;
      if (activeConfig == null) {
        return;
      }
      scale = Nav.rootScale();
      badgeScale = Math.max(3, 8 / Math.pow(scale, .5));
      hitScale = Math.max(3, 20 / scale);
      ref = activeConfig.paths;
      // path.parent.alpha is how we support multiple sheets â€” avoid scaling stuff on sheets that aren't visible
      for (j = 0, len = ref.length; j < len; j++) {
        path = ref[j];
        if (!(path.parent.alpha > 0)) {
          continue;
        }
        if (updateHits || path === hoveredPath) {
          ref1 = path.tracer.hits;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            hit = ref1[k];
            hit.strokeWidth = hitScale;
          }
        }
        if (updateBadges) {
          SVG.attrs(path.tracer.badge.zoomScale, {
            transform: `scale(${badgeScale})`
          });
        }
      }
      return null;
    };
    // STYLING #######################################################################################
    stylePath = function(path) {
      var child, color, colorIndex, glow, hit, isColored, isHover, j, k, l, len, len1, len2, ref, ref1, ref2;
      colorIndex = path.tracer.clickCount % activeConfig.colors.length;
      color = activeConfig.colors[colorIndex] || "#000";
      isHover = path.tracer.hovering;
      isColored = colorIndex !== 0;
      path.stroke = color;
      ref = path.children;
      for (j = 0, len = ref.length; j < len; j++) {
        child = ref[j];
        if (child !== path.tracer.badge) {
          child.alpha = isColored;
        }
      }
      ref1 = path.tracer.glows;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        glow = ref1[k];
        glow.stroke = color;
        glow.alpha = (function() {
          switch (false) {
            case !(!isColored && !isHover):
              return .08;
            case !(!isColored && isHover):
              return .3;
            case !(isColored && isHover):
              return 0;
            case !(isColored && !isHover):
              return .15;
          }
        })();
      }
      ref2 = path.tracer.hits;
      for (l = 0, len2 = ref2.length; l < len2; l++) {
        hit = ref2[l];
        // Even when the color is "transparent", there's a sizable perf benefit to having opaque alpha
        hit.stroke = isHover ? color : "transparent";
        hit.alpha = isHover ? .2 : 1;
      }
      return null;
    };
    updateBadge = function(path) {
      var props;
      if (path.tracer.isMistake) {
        if (path.tracer.animstate !== "incorrect") {
          path.tracer.animstate = "incorrect";
          path.tracer.badge.stroke = "hsl(358, 80%, 55%)"; // $red
          path.tracer.badge.scale = 2;
          path.tracer.badge.alpha = 0;
          path.tracer.badge.x = path.tracer.clickPos.x;
          path.tracer.badge.y = path.tracer.clickPos.y;
          SVG.attrs(path.tracer.badge.shape, {
            d: xShape
          });
          SVG.attrs(path.tracer.badge.shadow, {
            d: xShape
          });
          props = {
            scale: 1,
            alpha: 1
          };
          Tween.cancel(path.tracer.tween);
          return path.tracer.tween = Tween(path.tracer.badge, props, .2);
        }
      } else {
        if (path.tracer.animstate != null) {
          path.tracer.animstate = null;
          path.tracer.badge.stroke = "hsl(153, 80%, 41%)"; // $mint
          SVG.attrs(path.tracer.badge.shape, {
            d: checkShape
          });
          SVG.attrs(path.tracer.badge.shadow, {
            d: checkShape
          });
          props = {
            scale: 2,
            alpha: 0
          };
          Tween.cancel(path.tracer.tween);
          return path.tracer.tween = Tween(path.tracer.badge, props, 1);
        }
      }
    };
    unstylePath = function(path) {
      var child, glow, hit, j, k, l, len, len1, len2, ref, ref1, ref2;
      path.stroke = "#000";
      ref = path.children;
      for (j = 0, len = ref.length; j < len; j++) {
        child = ref[j];
        child.alpha = 1;
      }
      ref1 = path.tracer.glows;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        glow = ref1[k];
        glow.alpha = 0;
      }
      ref2 = path.tracer.hits;
      for (l = 0, len2 = ref2.length; l < len2; l++) {
        hit = ref2[l];
        hit.alpha = 0;
      }
      Tween.cancel(path.tracer.tween);
      path.tracer.badge.alpha = 0;
      return null;
    };
    // EVENTS ########################################################################################
    hitMoveIn = function(path) {
      return function() {
        if (!activeConfig) {
          return;
        }
        path.tracer.hovering = true;
        hoveredPath = path;
        return stylePath(path);
      };
    };
    hitMoveOut = function(path) {
      return function() {
        if (!activeConfig) {
          return;
        }
        path.tracer.hovering = false;
        if (hoveredPath === path) {
          hoveredPath = null;
        }
        return stylePath(path);
      };
    };
    startClick = function(path) {
      return function(e) {
        var ref;
        if (!activeConfig) {
          return;
        }
        if (!eventInside(e)) {
          return;
        }
        if (((ref = e.touches) != null ? ref.length : void 0) > 0) {
          e = e.touches[0];
        }
        return path.tracer.clicking = {
          x: e.clientX,
          y: e.clientY
        };
      };
    };
    cancelClick = function(path) {
      return function(e) {
        var d, ref;
        if (!activeConfig) {
          return;
        }
        if (!eventInside(e)) {
          return;
        }
        if (((ref = e.touches) != null ? ref.length : void 0) > 0) {
          e = e.touches[0];
        }
        if (path.tracer.clicking != null) {
          d = Vec.distance(path.tracer.clicking, {
            x: e.clientX,
            y: e.clientY
          });
          if (d >= 5) {
            return path.tracer.clicking = null;
          }
        }
      };
    };
    clickPath = function(path) {
      return function(e) {
        if (!activeConfig) {
          return;
        }
        if (path.tracer.clicking == null) {
          return;
        }
        if (!eventInside(e)) {
          return;
        }
        if (editing) {
          return editClick(path, e);
        } else {
          return gameClick(path);
        }
      };
    };
    setPathClickPos = function(path) {
      var child, closestDist, closestPoint, d, i, j, k, len, len1, p, p_path, p_screen, pathElm, ref, ref1, runtime, screenToPath, startTime, stepSize;
      // Create a point at the root of the SVG, and move it to the screen coords of the mouse position
      p_screen = SVG.svg.createSVGPoint();
      p_screen.x = path.tracer.clicking.x;
      p_screen.y = path.tracer.clicking.y;
      // Get a matrix that transfroms from screen coords to the coords of the path
      screenToPath = path.element.getScreenCTM().inverse();
      // Transform the point by that matrix
      p_path = p_screen.matrixTransform(screenToPath);
      // Now, find the point on the path that is closest to the mouse point
      stepSize = 10;
      closestPoint = null;
      closestDist = 2e308;
      startTime = performance.now(); // Measure the perf because querySelectorAll might be slow
      ref = path.tracer.originalChildren;
      for (j = 0, len = ref.length; j < len; j++) {
        child = ref[j];
        if (child._tracer_paths == null) {
          child._tracer_paths = child.querySelectorAll("path");
        }
        ref1 = child._tracer_paths;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          pathElm = ref1[k];
          i = pathElm.getTotalLength();
          while (i > 0) {
            p = pathElm.getPointAtLength(i);
            d = Vec.distance(p, p_path);
            if (d < closestDist) {
              closestDist = d;
              closestPoint = p;
            }
            i -= stepSize;
          }
        }
      }
      runtime = performance.now() - startTime;
      if (runtime > 5) {
        console.log(`Slow tracer click: ${runtime} ms`);
      }
      return path.tracer.clickPos = closestPoint;
    };
    // GAMEPLAY ######################################################################################
    editClick = function(path, e) {
      if (e.altKey) {
        return console.log(`Clicked ${getFullPathId(path)}`);
      } else {
        setPathClickPos(path);
        incPath(path);
        scorePath(path);
        return stylePath(path);
      }
    };
    gameClick = function(path) {
      var reaction;
      if (reaction = getReaction(path)) {
        return reaction(path);
      } else {
        setPathClickPos(path);
        incPath(path);
        scorePath(path);
        stylePath(path);
        updateBadge(path);
        checkForFirstMistakeEver(path);
        return checkForWin();
      }
    };
    getReaction = function(path) {
      var j, len, reaction, ref, ref1;
      if (((ref = activeConfig.reactions) != null ? ref.length : void 0) > 0) {
        ref1 = activeConfig.reactions;
        for (j = 0, len = ref1.length; j < len; j++) {
          reaction = ref1[j];
          if (indexOf.call(reaction.paths, path) >= 0) {
            return reaction.fn;
          }
        }
      }
      return null;
    };
    incPath = function(path) {
      return path.tracer.clickCount++;
    };
    delayedMistakePath = null;
    scorePath = function(path) {
      var clickedPastCorrect, isCorrect, nSets;
      nSets = activeConfig.colors.length;
      isCorrect = path.tracer.clickCount % nSets === path.tracer.desiredClicks;
      clickedPastCorrect = path.tracer.clickCount > path.tracer.desiredClicks;
      // Reset the path state
      path.tracer.isCorrect = false;
      path.tracer.isMistake = false;
      if (delayedMistakePath === path) {
        delayedMistakePath = null;
      }
      // Now, set the path to the correct state
      if (isCorrect) {
        return path.tracer.isCorrect = true;
      } else if (clickedPastCorrect) {
        return path.tracer.isMistake = true;
      } else {
        return delayedMistakePath = path;
      }
    };
    checkForIncorrectPaths = function(e) {
      if (activeConfig == null) {
        return;
      }
      if (delayedMistakePath == null) {
        return;
      }
      if (delayedMistakePath.element.contains(e.target)) {
        return;
      }
      delayedMistakePath.tracer.isMistake = true;
      stylePath(delayedMistakePath);
      updateBadge(delayedMistakePath);
      checkForFirstMistakeEver(delayedMistakePath, true);
      delayedMistakePath = null;
      return null;
    };
    window.addEventListener("click", checkForIncorrectPaths, true);
    window.addEventListener("touchend", checkForIncorrectPaths, true); // Hack: Input touchend preventDefault blocks click
    getIncorrectPaths = function() {
      var j, len, path, ref, results;
      ref = activeConfig.paths;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        path = ref[j];
        if (!path.tracer.isCorrect) {
          results.push(path);
        }
      }
      return results;
    };
    checkForWin = function() {
      if (getIncorrectPaths().length === 0) {
        return activeConfig.onWin(activeConfig);
      }
    };
    // FEEDBACK ######################################################################################
    noMistakesEver = true;
    checkForFirstMistakeEver = function(path, forced) {
      var clickedPastCorrect, isIncorrect;
      if (!noMistakesEver) {
        return;
      }
      isIncorrect = (path.tracer.clickPos != null) && !path.tracer.isCorrect;
      clickedPastCorrect = path.tracer.clickCount > path.tracer.desiredClicks;
      if (isIncorrect && (clickedPastCorrect || forced)) {
        Wait(.5, function() {
          return Panel.alert(`<h3>That path is incorrect.</h3>
<p style="margin-top:.5em">
  To fix it, keep clicking the path.
</p>
<p style="margin-top:.5em">
  Once the path is set correctly for<br>
  this circuit, the
  <svg style="vertical-align:middle" width="1.2em" height="1.2em" viewBox="-2 -2 4 4" fill="none" stroke-linecap="round">
    <path stroke="#FFF" stroke-width="1.2" d="M-1,-1 L1,1 M-1,1 L1,-1"/>
    <path stroke-width=".7" stroke="hsl(358, 80%, 55%)" d="M-1,-1 L1,1 M-1,1 L1,-1"/>
  </svg>
  mark will disappear.
</p>`);
        });
        return noMistakesEver = false;
      }
    };
    // EDITING #######################################################################################
    editingSetupDone = false;
    setupEditing = function() {
      var debugPoint;
      editing = true;
      if (editingSetupDone) {
        return;
      }
      editingSetupDone = true;
      Control.label({
        name: "Path Tracer Edit Mode",
        group: "#F80"
      });
      Control.button({
        name: "Copy Solution",
        group: "#F80",
        click: saveConfiguration
      });
      if (Nav != null) {
        Nav.runResize(); // This is needed to make the new panel buttons appear
      }
      debugPoint = Scope(SVG.create("g", SVG.svg));
      debugPoint.debug.point();
      debugPoint.hide(0);
      Resize(function() {
        debugPoint.x = Nav.center().x;
        return debugPoint.y = Nav.center().y;
      });
      window.addEventListener("keydown", function(e) {
        if (e.keyCode === 32) {
          return debugPoint.show(0);
        }
      });
      return window.addEventListener("keyup", function(e) {
        if (e.keyCode === 32) {
          debugPoint.hide(0);
          return console.log(Nav.pos());
        }
      });
    };
    saveConfiguration = function() {
      var c, colorIndex, j, len, nSets, path, ref, solution, text;
      // Sort all selected paths into solution sets
      nSets = activeConfig.colors.length;
      solution = (function() {
        var j, ref, results;
        results = [];
        for (c = j = 0, ref = nSets; (0 <= ref ? j < ref : j > ref); c = 0 <= ref ? ++j : --j) {
          results.push([]);
        }
        return results;
      })();
      ref = activeConfig.paths;
      for (j = 0, len = ref.length; j < len; j++) {
        path = ref[j];
        colorIndex = path.tracer.clickCount % nSets;
        solution[colorIndex].push(path);
      }
      // We don't care about the paths in the default / un-clicked set
      solution.shift();
      // Format the solution sets into coffeescript text
      text = JSON.stringify({
        solution: solution.map(function(paths) {
          return paths.map(getFullPathId);
        })
      });
      // Put the solution coffeescript text onto the clipboard
      return navigator.clipboard.writeText(text).then(function() {
        return console.log("Copied current configuration to clipboard");
      });
    };
    // MAIN ##########################################################################################
    return Make("Tracer", Tracer = {
      edit: function(config) {
        Tracer.stop();
        activeConfig = config; // We should probably clone the config, so we can mutate it without fear
        setupEditing();
        return setupPaths();
      },
      play: function(config) {
        Tracer.stop();
        activeConfig = config; // We should probably clone the config, so we can mutate it without fear
        return setupPaths();
      },
      stop: function() {
        var j, len, path, ref;
        if (activeConfig != null) {
          editing = false;
          ref = activeConfig.paths;
          for (j = 0, len = ref.length; j < len; j++) {
            path = ref[j];
            unstylePath(path);
          }
          return activeConfig = null;
        }
      },
      refresh: function() {
        return updateZoomScaling(true, true);
      },
      getIncorrectPaths: getIncorrectPaths
    });
  });

}).call(this);
