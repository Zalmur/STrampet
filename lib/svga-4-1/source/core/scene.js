// Generated by CoffeeScript 2.7.0
(function() {
  // This system is mainly in charge of crawling the DOM, doing some initial cleanup,
  // and building a tree of important elements for animation.
  var indexOf = [].indexOf;

  Take(["Mode", "Scope", "SVG", "Symbol"], function(Mode, Scope, SVG, Symbol) {
    var Scene, buildScopes, cleanupIds, defs, deprecations, masks, processElm, removeUselessLayers;
    deprecations = ["controlPanel", "ctrlPanel", "navOverlay"];
    masks = [];
    defs = {};
    Make("Scene", Scene = {
      crawl: function(elm) {
        var tree;
        cleanupIds(elm);
        tree = processElm(elm);
        if (masks.length) {
          console.log("Please remove these mask elements from your SVG:", ...masks);
        }
        masks = null; // Avoid dangling references
        defs = null; // Avoid dangling references
        return tree;
      },
      build: function(tree) {
        var i, setup, setups;
        buildScopes(tree, setups = []);
// loop backwards, to set up children before parents
        for (i = setups.length - 1; i >= 0; i += -1) {
          setup = setups[i];
          setup();
        }
        return void 0;
      }
    });
    cleanupIds = function(elm) {
      var element, i, len, ref;
      if (!Mode.dev) {
        return;
      }
      ref = elm.querySelectorAll("[id]");
      // By default, elements with an ID are added to the window object.
      // For the sake of better typo handling, we replace those references with a proxy.
      for (i = 0, len = ref.length; i < len; i++) {
        element = ref[i];
        if (window[element.id] != null) {
          (function(element) {
            var handlers;
            handlers = {
              get: function() {
                console.log(element);
                throw "You forgot to use an @ when accessing the scope for this element ^^^";
              },
              set: function(val) {
                console.log(element);
                throw "You forgot to use an @ when accessing the scope for this element ^^^";
              }
            };
            return window[element.id] = new Proxy({}, handlers);
          })(element);
        }
      }
      return void 0;
    };
    removeUselessLayers = function(containerElm) {
      var childElm, i, isGroup, isUselessLayer, j, layerSuspect, layerSuspects, len, len1, ref, ref1, results;
      // In recent versions of Adobe Animate, groups are sometimes created to house layer contents,
      // where previous versions wouldn't do this. This creates a weird mismatch between new and old code.
      // To work around this, we detect these extra layer elements, and remove them before building
      // the scope tree.
      layerSuspects = Array.prototype.slice.call(containerElm.childNodes);
      results = [];
      for (i = 0, len = layerSuspects.length; i < len; i++) {
        layerSuspect = layerSuspects[i];
        isGroup = layerSuspect instanceof SVGGElement;
        isUselessLayer = ((ref = layerSuspect.id) != null ? ref.search(/L_\d+/) : void 0) >= 0;
        if (isGroup && isUselessLayer) {
          ref1 = Array.prototype.slice.call(layerSuspect.childNodes);
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            childElm = ref1[j];
            containerElm.insertBefore(childElm, layerSuspect);
          }
          results.push(containerElm.removeChild(layerSuspect));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    processElm = function(elm) {
      var childElm, childNodes, clone, def, defId, i, len, ref, ref1, tree;
      tree = {
        elm: elm,
        sub: []
      };
      removeUselessLayers(elm);
      childNodes = Array.prototype.slice.call(elm.childNodes);
      for (i = 0, len = childNodes.length; i < len; i++) {
        childElm = childNodes[i];
        if ((ref = childElm.id, indexOf.call(deprecations, ref) >= 0)) {
          console.log(`#${childElm.id} is obsolete. Please remove it from your FLA and re-export this SVG.`);
          elm.removeChild(childElm);
        // clipPath masks are generated by Flash to wrap text, for some reason
        } else if (childElm.tagName === "clipPath") {
          elm.removeChild(childElm);
        } else if (childElm.tagName === "text") {
          if (typeof childElm.removeAttribute === "function") {
            childElm.removeAttribute("clip-path");
          }
        } else if (((ref1 = childElm.id) != null ? ref1.indexOf("Mask") : void 0) > -1) {
          masks.push(childElm.id);
          elm.removeChild(childElm);
        } else if (childElm instanceof SVGGElement) {
          tree.sub.push(processElm(childElm));
        } else if (childElm instanceof SVGUseElement) {
          // We make a clone of the use'd element in defs, so that we can reach in and change (eg) strokes/fills.
          defId = childElm.getAttribute("xlink:href");
          def = defs[defId] != null ? defs[defId] : defs[defId] = SVG.defs.querySelector(defId);
          clone = def.cloneNode(true);
          elm.replaceChild(clone, childElm);
          if (def.parentNode != null) {
            def.parentNode.removeChild(def);
          }
          if (clone instanceof SVGGElement) {
            tree.sub.push(processElm(clone));
          }
        }
      }
      return tree;
    };
    // BUILD SCOPES ##################################################################################
    return buildScopes = function(tree, setups, parentScope = null) {
      var baseName, i, len, props, ref, ref1, scope, subTarget, symbol;
      props = {
        parent: parentScope
      };
      if (tree.elm.id.replace(/_FL/g, "").length > 0) {
        props.id = tree.elm.id.replace(/_FL/g, "");
      }
      // This is a bit of a legacy hack, where symbols are given names in Flash so that our code can hook up with them.
      baseName = (ref = tree.elm.id) != null ? ref.split("_")[0] : void 0;
      symbol = baseName.indexOf("Line") > -1 || baseName.indexOf("line") === 0 ? Symbol.forSymbolName("HydraulicLine") : baseName.indexOf("Field") > -1 || baseName.indexOf("field") === 0 ? Symbol.forSymbolName("HydraulicField") : baseName.indexOf("BackgroundCover") > -1 ? Symbol.forSymbolName("BackgroundCover") : props.id != null ? Symbol.forInstanceName(props.id) : void 0;
      if (symbol == null) {
        symbol = function() {
          return {};
        };
      }
      scope = Scope(tree.elm, symbol, props);
      if (scope.setup != null) {
        setups.push(scope.setup.bind(scope));
      }
      ref1 = tree.sub;
      for (i = 0, len = ref1.length; i < len; i++) {
        subTarget = ref1[i];
        buildScopes(subTarget, setups, scope);
      }
      return void 0;
    };
  });

}).call(this);
